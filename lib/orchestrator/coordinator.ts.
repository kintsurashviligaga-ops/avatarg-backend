import { createClient } from '@supabase/supabase-js';
import { v4 as uuidv4 } from 'uuid';

const supabaseUrl = process.env.VITE_SUPABASE_URL!;
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;
const supabase = createClient(supabaseUrl, supabaseServiceKey);

// ============================================================================
// TYPES
// ============================================================================

interface ProjectInput {
  userId: string;
  projectId: string;
  userPrompt: string;
  brandContext?: Record<string, unknown>;
  referenceAssets?: string[];
}

interface OrchestrationResult {
  success: boolean;
  projectId: string;
  renderJobId?: string;
  error?: string;
}

// ============================================================================
// MAIN COORDINATOR
// ============================================================================

export class ProductionCoordinator {
  /**
   * Master orchestration function
   * Flow: DeepSeek (Script) → Gemini (Visual Prompts) → Shotstack (Assembly)
   */
  async orchestrate(input: ProjectInput): Promise<OrchestrationResult> {
    const { projectId, userId, userPrompt, brandContext } = input;

    try {
      console.log(`[Coordinator] Starting orchestration for project ${projectId}`);

      // ========================================================================
      // STEP 1: Generate Script with DeepSeek (Reasoning)
      // ========================================================================
      
      const scriptResult = await this.generateScript(projectId, userPrompt, brandContext);
      
      if (!scriptResult.success) {
        throw new Error(`Script generation failed: ${scriptResult.error}`);
      }

      const script = scriptResult.content!;
      console.log(`[Coordinator] Script generated: ${script.substring(0, 100)}...`);

      // ========================================================================
      // STEP 2: Generate Visual Prompts with Gemini (Multimodal)
      // ========================================================================
      
      const visualPromptsResult = await this.generateVisualPrompts(
        projectId,
        script,
        brandContext
      );

      if (!visualPromptsResult.success) {
        throw new Error(`Visual prompt generation failed: ${visualPromptsResult.error}`);
      }

      const visualPrompts = visualPromptsResult.prompts!;
      console.log(`[Coordinator] Generated ${visualPrompts.length} visual prompts`);

      // ========================================================================
      // STEP 3: Generate Assets (Leonardo/Udio with Fallbacks)
      // ========================================================================
      
      const assetsResult = await this.generateAssets(projectId, visualPrompts, script);

      if (!assetsResult.success) {
        throw new Error(`Asset generation failed: ${assetsResult.error}`);
      }

      const { imageUrls, audioUrl } = assetsResult;
      console.log(`[Coordinator] Assets ready: ${imageUrls.length} images, audio: ${audioUrl}`);

      // ========================================================================
      // STEP 4: Build Shotstack Timeline
      // ========================================================================
      
      const timelineResult = await this.buildShotstackTimeline(
        projectId,
        imageUrls,
        audioUrl,
        script
      );

      if (!timelineResult.success) {
        throw new Error(`Timeline build failed: ${timelineResult.error}`);
      }

      const timeline = timelineResult.timeline!;

      // ========================================================================
      // STEP 5: Submit Render Job to Shotstack
      // ========================================================================
      
      const renderResult = await this.submitShotstackRender(projectId, timeline);

      if (!renderResult.success) {
        throw new Error(`Shotstack render failed: ${renderResult.error}`);
      }

      // ========================================================================
      // STEP 6: Update Project Status
      // ========================================================================
      
      await supabase
        .from('projects')
        .update({
          status: 'processing',
          shotstack_render_id: renderResult.renderId,
          updated_at: new Date().toISOString()
        })
        .eq('id', projectId);

      console.log(`[Coordinator] ✅ Orchestration complete. Render ID: ${renderResult.renderId}`);

      return {
        success: true,
        projectId,
        renderJobId: renderResult.renderId
      };

    } catch (error: any) {
      console.error(`[Coordinator] ❌ Orchestration failed:`, error);

      // Update project status to failed
      await supabase
        .from('projects')
        .update({
          status: 'failed',
          metadata: { error: error.message }
        })
        .eq('id', projectId);

      return {
        success: false,
        projectId,
        error: error.message
      };
    }
  }

  // ==========================================================================
  // STEP 1: Script Generation (DeepSeek)
  // ==========================================================================

  private async generateScript(
    projectId: string,
    userPrompt: string,
    brandContext?: Record<string, unknown>
  ): Promise<{ success: boolean; content?: string; error?: string }> {
    try {
      const response = await fetch('https://api.deepseek.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${process.env.DEEPSEEK_API_KEY}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model: 'deepseek-reasoner',
          messages: [
            {
              role: 'system',
              content: `You are a professional scriptwriter. Create a concise 30-second video script based on the user's prompt. Include narration and scene descriptions. ${brandContext ? `Brand context: ${JSON.stringify(brandContext)}` : ''}`
            },
            {
              role: 'user',
              content: userPrompt
            }
          ],
          max_tokens: 1000
        })
      });

      if (!response.ok) {
        throw new Error(`DeepSeek API error: ${response.status}`);
      }

      const data = await response.json();
      const content = data.choices[0].message.content;

      // Store in content_segments
      await supabase.from('content_segments').insert({
        project_id: projectId,
        segment_type: 'script',
        provider: 'deepseek',
        model: 'deepseek-reasoner',
        content,
        tokens_used: data.usage?.total_tokens
      });

      return { success: true, content };

    } catch (error: any) {
      console.error('[Script Generation] Error:', error);
      return { success: false, error: error.message };
    }
  }

  // ==========================================================================
  // STEP 2: Visual Prompts Generation (Gemini)
  // ==========================================================================

  private async generateVisualPrompts(
    projectId: string,
    script: string,
    brandContext?: Record<string, unknown>
  ): Promise<{ success: boolean; prompts?: string[]; error?: string }> {
    try {
      const apiKey = process.env.GEMINI_API_KEY;
      const model = 'gemini-1.5-pro';
      const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;

      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          contents: [
            {
              role: 'user',
              parts: [
                {
                  text: `Given this video script, generate 3-5 visual prompts for image generation. Each prompt should describe a key scene. Output as JSON array.

Script: ${script}

${brandContext ? `Brand Context: ${JSON.stringify(brandContext)}` : ''}

Output format: ["prompt 1", "prompt 2", ...]`
                }
              ]
            }
          ],
          generationConfig: {
            maxOutputTokens: 800,
            temperature: 0.7
          }
        })
      });

      if (!response.ok) {
        throw new Error(`Gemini API error: ${response.status}`);
      }

      const data = await response.json();
      const content = data.candidates[0].content.parts[0].text;

      // Parse prompts from JSON
      const promptsMatch = content.match(/\[.*\]/s);
      const prompts = promptsMatch ? JSON.parse(promptsMatch[0]) : [];

      // Store in content_segments
      for (let i = 0; i < prompts.length; i++) {
        await supabase.from('content_segments').insert({
          project_id: projectId,
          segment_type: 'visual_prompt',
          segment_order: i,
          provider: 'gemini',
          model: 'gemini-1.5-pro',
          content: prompts[i]
        });
      }

      return { success: true, prompts };

    } catch (error: any) {
      console.error('[Visual Prompts] Error:', error);
      return { success: false, error: error.message };
    }
  }

  // ==========================================================================
  // STEP 3: Asset Generation (Leonardo/Udio with Fallbacks)
  // ==========================================================================

  private async generateAssets(
    projectId: string,
    visualPrompts: string[],
    script: string
  ): Promise<{
    success: boolean;
    imageUrls?: string[];
    audioUrl?: string;
    error?: string;
  }> {
    try {
      const imageUrls: string[] = [];
      const audioUrl: string;

      // -----------------------------------------------------------------
      // Images: Try Leonardo, fallback to static assets
      // -----------------------------------------------------------------
      
      const leonardoKey = process.env.LEONARDO_API_KEY;

      if (leonardoKey) {
        console.log('[Asset Gen] Using Leonardo for images');
        
        // TODO: Implement Leonardo API calls
        // For now, use fallback
        imageUrls.push(...await this.getFallbackImages(projectId, visualPrompts.length));
        
      } else {
        console.log('[Asset Gen] Leonardo key missing, using fallback images');
        imageUrls.push(...await this.getFallbackImages(projectId, visualPrompts.length));
      }

      // -----------------------------------------------------------------
      // Audio: Try Udio, fallback to static asset
      // -----------------------------------------------------------------
      
      const udioKey = process.env.UDIO_API_KEY;

      if (udioKey) {
        console.log('[Asset Gen] Using Udio for audio');
        
        // TODO: Implement Udio API calls
        // For now, use fallback
        audioUrl = await this.getFallbackAudio(projectId);
        
      } else {
        console.log('[Asset Gen] Udio key missing, using fallback audio');
        audioUrl = await this.getFallbackAudio(projectId);
      }

      return { success: true, imageUrls, audioUrl };

    } catch (error: any) {
      console.error('[Asset Generation] Error:', error);
      return { success: false, error: error.message };
    }
  }

  // ==========================================================================
  // STEP 4: Build Shotstack Timeline
  // ==========================================================================

  private async buildShotstackTimeline(
    projectId: string,
    imageUrls: string[],
    audioUrl: string,
    script: string
  ): Promise<{ success: boolean; timeline?: any; error?: string }> {
    try {
      // Build video track with images
      const videoClips = imageUrls.map((url, index) => ({
        asset: {
          type: 'image',
          src: url
        },
        start: index * 5, // 5 seconds per image
        length: 5,
        transition: {
          in: 'fade',
          out: 'fade'
        }
      }));

      // Build audio track
      const audioClip = {
        asset: {
          type: 'audio',
          src: audioUrl
        },
        start: 0,
        length: imageUrls.length * 5
      };

      const timeline = {
        timeline: {
          tracks: [
            {
              clips: videoClips
            },
            {
              clips: [audioClip]
            }
          ]
        },
        output: {
          format: 'mp4',
          resolution: 'sd'
        }
      };

      // Store timeline in asset_library
      await supabase.from('asset_library').insert({
        project_id: projectId,
        asset_type: 'shotstack_timeline',
        asset_source: 'shotstack',
        asset_url: 'timeline://generated',
        metadata: { timeline }
      });

      return { success: true, timeline };

    } catch (error: any) {
      console.error('[Timeline Build] Error:', error);
      return { success: false, error: error.message };
    }
  }

  // ==========================================================================
  // STEP 5: Submit Shotstack Render
  // ==========================================================================

  private async submitShotstackRender(
    projectId: string,
    timeline: any
  ): Promise<{ success: boolean; renderId?: string; error?: string }> {
    try {
      const response = await fetch('https://api.shotstack.io/v1/render', {
        method: 'POST',
        headers: {
          'x-api-key': process.env.SHOTSTACK_API_KEY!,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(timeline)
      });

      if (!response.ok) {
        throw new Error(`Shotstack API error: ${response.status}`);
      }

      const data = await response.json();
      const renderId = data.response.id;

      // Create job queue entry
      await supabase.from('job_queue').insert({
        project_id: projectId,
        job_type: 'render',
        status: 'queued',
        provider: 'shotstack',
        provider_job_id: renderId,
        input_data: timeline,
        queued_at: new Date().toISOString()
      });

      return { success: true, renderId };

    } catch (error: any) {
      console.error('[Shotstack Render] Error:', error);
      return { success: false, error: error.message };
    }
  }

  // ==========================================================================
  // FALLBACK HELPERS
  // ==========================================================================

  private async getFallbackImages(projectId: string, count: number): Promise<string[]> {
    const staticImages = [
      'https://shotstack-assets.s3.amazonaws.com/images/realestate1.jpg',
      'https://shotstack-assets.s3.amazonaws.com/images/realestate2.jpg',
      'https://shotstack-assets.s3.amazonaws.com/images/realestate3.jpg',
      'https://shotstack-assets.s3.amazonaws.com/images/realestate4.jpg',
      'https://shotstack-assets.s3.amazonaws.com/images/realestate5.jpg'
    ];

    const urls = staticImages.slice(0, Math.min(count, staticImages.length));

    // Store in asset_library
    for (const url of urls) {
      await supabase.from('asset_library').insert({
        project_id: projectId,
        asset_type: 'image',
        asset_source: 'static_fallback',
        asset_url: url,
        metadata: { fallback: true }
      });
    }

    return urls;
  }

  private async getFallbackAudio(projectId: string): Promise<string> {
    const staticAudio = 'https://shotstack-assets.s3.amazonaws.com/music/disco.mp3';

    // Store in asset_library
    await supabase.from('asset_library').insert({
      project_id: projectId,
      asset_type: 'audio',
      asset_source: 'static_fallback',
      asset_url: staticAudio,
      metadata: { fallback: true }
    });

    return staticAudio;
  }
}
