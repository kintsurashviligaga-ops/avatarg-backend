import { NextResponse } from "next/server";
import { S3Client, PutObjectCommand } from "@aws-sdk/client-s3";
import { getSignedUrl } from "@aws-sdk/s3-request-presigner";

export const runtime = "nodejs"; // AWS SDK best on Node runtime

/**
 * Required env vars (Vercel Project Env Vars):
 *  - R2_ENDPOINT            e.g. https://<ACCOUNT_ID>.r2.cloudflarestorage.com
 *  - R2_ACCESS_KEY_ID
 *  - R2_SECRET_ACCESS_KEY
 *  - R2_BUCKET_NAME         e.g. avatar-g-media
 *
 * Optional:
 *  - ALLOWED_ORIGINS        comma-separated, e.g. https://avatar-g.vercel.app,https://yourdomain.com
 *  - R2_PUBLIC_BASE_URL     e.g. https://media.yourdomain.com   (custom domain) OR public dev url base
 */

function mustGetEnv(name: string): string {
  const v = process.env[name];
  if (!v) throw new Error(`Missing env: ${name}`);
  return v;
}

function getAllowedOrigins(): string[] {
  const raw = process.env.ALLOWED_ORIGINS || "";
  return raw
    .split(",")
    .map((s) => s.trim())
    .filter(Boolean);
}

function corsHeaders(req: Request): HeadersInit {
  const origin = req.headers.get("origin") || "";
  const allowed = getAllowedOrigins();

  // If no ALLOWED_ORIGINS set -> allow all (dev-friendly)
  const allowOrigin =
    allowed.length === 0
      ? "*"
      : allowed.includes(origin)
      ? origin
      : allowed[0]; // fallback (prevents empty header)

  return {
    "Access-Control-Allow-Origin": allowOrigin,
    "Access-Control-Allow-Methods": "POST, OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type, Authorization",
    "Access-Control-Max-Age": "86400",
  };
}

function json(req: Request, data: any, status = 200) {
  return NextResponse.json(data, {
    status,
    headers: {
      ...corsHeaders(req),
      "Cache-Control": "no-store",
    },
  });
}

function getS3Client() {
  const endpoint = mustGetEnv("R2_ENDPOINT");
  const accessKeyId = mustGetEnv("R2_ACCESS_KEY_ID");
  const secretAccessKey = mustGetEnv("R2_SECRET_ACCESS_KEY");

  return new S3Client({
    region: "auto",
    endpoint,
    credentials: { accessKeyId, secretAccessKey },
  });
}

function sanitizeKey(input: string) {
  // Remove leading slashes and dangerous segments
  let k = (input || "").trim().replace(/^\/+/, "");
  k = k.replace(/\.\./g, "");
  // Optionally limit length
  if (k.length > 512) k = k.slice(0, 512);
  return k;
}

function inferExtFromContentType(contentType: string) {
  const ct = (contentType || "").toLowerCase();
  if (ct.includes("image/jpeg")) return "jpg";
  if (ct.includes("image/png")) return "png";
  if (ct.includes("image/webp")) return "webp";
  if (ct.includes("image/gif")) return "gif";
  if (ct.includes("video/mp4")) return "mp4";
  if (ct.includes("video/webm")) return "webm";
  if (ct.includes("audio/mpeg")) return "mp3";
  if (ct.includes("audio/wav")) return "wav";
  if (ct.includes("audio/ogg")) return "ogg";
  return "";
}

export async function OPTIONS(req: Request) {
  return new NextResponse(null, { status: 204, headers: corsHeaders(req) });
}

/**
 * POST body (JSON):
 * {
 *   "key": "uploads/abc.png"          // optional (if not provided -> autogenerated)
 *   "folder": "uploads"              // optional
 *   "contentType": "image/png"       // required
 *   "expiresIn": 600                 // optional (seconds) default 600, max 3600
 * }
 *
 * Response:
 * {
 *   ok: true,
 *   key: "...",
 *   bucket: "...",
 *   uploadUrl: "https://...signed...",
 *   publicUrl: "https://.../key"     // only if R2_PUBLIC_BASE_URL is set
 * }
 */
export async function POST(req: Request) {
  try {
    let body: any = null;
    try {
      body = await req.json();
    } catch {
      return json(req, { ok: false, code: "INVALID_JSON", error: "Body must be valid JSON" }, 400);
    }

    const bucket = mustGetEnv("R2_BUCKET_NAME");
    const contentType = String(body?.contentType || "").trim();

    if (!contentType) {
      return json(
        req,
        { ok: false, code: "MISSING_CONTENT_TYPE", error: "contentType is required" },
        400
      );
    }

    // Optional restrictions (you can expand)
    const allowedPrefixes = ["image/", "video/", "audio/", "application/pdf"];
    const isAllowed = allowedPrefixes.some((p) => contentType.toLowerCase().startsWith(p));
    if (!isAllowed) {
      return json(
        req,
        {
          ok: false,
          code: "UNSUPPORTED_CONTENT_TYPE",
          error: `Unsupported contentType: ${contentType}`,
        },
        415
      );
    }

    let expiresIn = Number(body?.expiresIn ?? 600);
    if (!Number.isFinite(expiresIn) || expiresIn <= 0) expiresIn = 600;
    if (expiresIn > 3600) expiresIn = 3600; // max 1h

    const folder = String(body?.folder || "uploads").trim().replace(/^\/+/, "").replace(/\.\./g, "");
    const providedKey = body?.key ? String(body.key) : "";

    // Generate a safe key if none provided
    const ext = inferExtFromContentType(contentType);
    const rand = crypto.randomUUID();
    const autoKey = `${folder}/${Date.now()}-${rand}${ext ? "." + ext : ""}`;
    const key = sanitizeKey(providedKey || autoKey);

    const s3 = getS3Client();

    const command = new PutObjectCommand({
      Bucket: bucket,
      Key: key,
      ContentType: contentType,
      // You can add metadata if needed:
      // Metadata: { app: "avatar-g" },
    });

    const uploadUrl = await getSignedUrl(s3, command, { expiresIn });

    const publicBase = (process.env.R2_PUBLIC_BASE_URL || "").trim().replace(/\/+$/, "");
    const publicUrl = publicBase ? `${publicBase}/${encodeURI(key)}` : null;

    return json(req, { ok: true, bucket, key, uploadUrl, publicUrl }, 200);
  } catch (e: any) {
    // Do not leak secrets; return safe error
    return json(
      req,
      {
        ok: false,
        code: "SERVER_ERROR",
        error: "Failed to create signed upload URL",
        details: e?.message ? String(e.message).slice(0, 300) : undefined,
      },
      500
    );
  }
}
